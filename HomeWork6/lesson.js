// Об'єктно-Орієнтоване Програмування (ООП) - один з методів програмування,який розглядає програму як множину «об'єктів», що взаємодіють між собою.

// ООП представляє програмне забезпечення як сукупність взаємних об'єктів, а не
// просто набір команд чи функцій як у традиційному програмуванні.

// У JavaScript є багато об'єктів які є вбудовані у ядро, так звані стандартні об'єкти
// JavaScript наприклад: String, Number, Date і т. д.

// Кожен стандартний об'єкт являється екземпляром об'єкта Object, наслідуючи
// його властивості і методи.

// У JavaScript об'єкти це сукупність методів і властивостей.

//Приклад. У нас є кредит і треба розрахувати його сумму. Це процедурне програмування.

// const sum = 20000;
// const month = 12;
// const p = 1000;

// const credit = (sum, date, p) => {
//   return sum + p * date;
// };

// console.log(credit(sum, month, p));

// А тепер робимо Об'єктно-Орієнтоване Програмування

// const credit = {
//   sum: 20000,
//   month: 12,
//   p: 1000,
//   result() {
//     return this.sum + this.p * this.month;
//   },
// };

// console.log(credit.result());

//класи це шаблони для створення об'єктів, які мають спільні властивості та методи.

// Клас - спосіб опису сутності, що визначає стан і поведінку, що залежить від цього
// стану, а також правила для взаємодії з цією сутністю (контракт).
// У нашому випадку клас описує сутність – телефон. Властивістю класу будуть
// камера, модем, дисплей і т.д. Методами класу дзвонити, фотографувати і т.п.

//1

// class Bank {
//   constructor(option) {
//     this.sum = option.sum;
//     this.month = option.month;
//     this.p = option.p;
//   }

//   credit() {
//     return console.log(this.sum + this.p * this.month);
//   }
// }

// const userBank = new Bank({
//   sum: 30000,
//   month: 5,
//   p: 500,
// });

// userBank.credit();

//2

// class Bank {
//   static type = 'Privat';
//   constructor(option) {
//     this.sum = option.sum;
//     this.month = option.month;
//     this.p = option.p;
//   }

//---///

//   credit() {
//     return console.log(this.sum + this.p * this.month);
//   }

//   credit() {
//     return console.log("I'm Privat");
//   }
// }

//---//

// class NewBank extends Bank {
//   constructor(option) {
//     super(option);
//     this.card = option.card;
//   }
//   credit() {
//     super.credit();
//     return console.log("I'm Aval");
//   }
// }

// const aval = new NewBank({
//   sum: 30000,
//   month: 5,
//   p: 500,
//   card: true,
// });

// console.log(aval.credit());

//get & set (get - коли считуємо інформацію , set- коли змінюємо інформацію)

//1

// class User {
//   constructor(props) {
//     this.name = props.name;
//   }

//   firstName = '';
//   lastName = '';
//   age = '';
//   city = '';

//   set name(newName) {
//     const nameRow = newName.split(' ');
//     this.firstName = nameRow[0];
//     this.lastName = nameRow[1];
//   }

//   get name() {
//     return ` First name: ${this.firstName} Last name: ${this.lastName}`;
//   }
// }

// const Kris = new User({
//   name: 'Kristina Malitowska',
// });

// const Pol = new User({
//   name: 'Polina Pikalova',
// });

// console.log(Kris);
// console.log(Pol);

// Об'єкт

// Ми спроектували креслення і схеми, за ними телефони сходять з конвеєра .
// Кожен з них точно повторює креслення, всі системи взаємодіють саме так, як ми
// спроектували, але кожен телефон є унікальним. Всі вони мають індивідуальний
// номер телефону , телефони відрізняються кольором, малюнком на панелі і тд. Ці
// телефони є екземплярами класу.

// Об'єкт (примірник) - це окремий представник класу, що має конкретний стан і
// поведінку, що повністю визначається класом. Це те, що створено за кресленням,
// тобто за описом із класу.

// Говорячи простою мовою, об'єкт має конкретні значення властивостей та методи,
// що працюють із цими властивостями на основі правил, заданих у класі. У даному
// прикладі, якщо клас це якийсь абстрактний телефон на кресленні, то об'єкт — це
// конкретний телефон, яким ви користуєтесь

//Прототипи

// const a = [1, 2, 3];
// console.log(a);

// const a = {
//   x: 1,
//   y: 2,
// };

// const b = Object.create(a); //визвали a у b

// console.log(b);

// У нас є магазин і в магазині є менеджери , у кожного менеджера своя знижка і ця знижка росте кожен місяць на 1

//1

// const Manager = function (name, sales) {
//   this.name = name;
//   this.sales = sales;

//   this.sale = function () {
//     this.sales += 1;
//   };
// };

// const ann = new Manager('Anna', 5);
// const ivan = new Manager('Ivan', 10);

// console.log(ann.sales);
// ann.sale();
// console.log(ann.sales);

//2

// const Manager = function (name, sales) {
//   this.name = name;
//   this.sales = sales;
// };

// const ann = new Manager('Anna', 5);
// const ivan = new Manager('Ivan', 10);

// Manager.prototype.sale = function () {
//   this.sales += 1;
// };

// console.log(ann.sales);
// ann.sale();
// console.log(ann.sales);

//3 просто перевірка через console.dir

// const Manager = function (name, sales) {
//   this.name = name;
//   this.sales = sales;
// };

// const ann = new Manager('Anna', 5);
// const ivan = new Manager('Ivan', 10);

// Manager.prototype.sale = function () {
//   this.sales += 1;
// };

// console.dir(Manager);

//4

// class CoffeeMachine {
//   _water = 0;

//   constructor(power) {
//     this.power = power;
//   }

//   set waterAmount(value) {
//     if (value < 0) {
//       value = 0;
//     }
//     this._water = value;
//   }
// }

// let coffeeMachine = new CoffeeMachine(100);

// coffeeMachine.waterAmount = 20; //+
// coffeeMachine.waterAmount = -20; //буде 0

// console.log(coffeeMachine);

// Інтерфейс

// Коли ми підходимо до автомата з кавою або сідаємо за кермо автомобіля, існує
// певний набір елементів керування, з якими ми можемо взаємодіяти.
// Інтерфейс – це набір властивостей та методів класу, доступних для використання
// під час роботи з екземпляром.

// Насправді, інтерфейс специфікує клас, чітко визначаючи всі можливі дії над ним.
// Хороший приклад інтерфейсу - панель приладів автомобіля, яка дозволяє
// викликати такі методи як збільшення швидкості, гальмування, поворот,
// перемикання передач, включення фар і т. п.

// При описі інтерфейсу класу дуже важливо дотриматися балансу між гнучкістю і
// простотою. Клас із простим інтерфейсом буде легко використовувати, але
// існуватимуть завдання, які за допомогою нього вирішити буде не під силу. Якщо
// інтерфейс буде гнучким, то швидше за все, він складатиметься з досить складних
// методів з великою кількістю параметрів, які дозволятимуть робити дуже багато,
// але його використання буде пов'язане з великими складнощами та ризиком
// зробити помилку, щось переплутавши.

// Парадигми

// ООП побудовано на чотирьох основних поняттях: інкапсуляція, абстракція,
// наслідування та поліморфізм.

// Інкапсуляція

// Внутрішні процеси роботи телефону досить складні. Але всі ці дії приховані від
// користувача і дозволяють йому дзвонити і писати, не замислюючись, що
// відбувається всередині. Саме приховування внутрішніх процесів, що відбуваються
// в телефоні, дозволяє ефективно використовувати його навіть новачкам. Це і є
// інкапсуляція.

// Інкапсуляція (encapsulation) - це властивість системи, що дозволяє об'єднати дані
// та методи, що працюють з ними, у класі та приховати деталі реалізації від
// користувача.

// Інкапсуляція пов'язана з поняттям інтерфейсу класу. Все те, що не входить до
// інтерфейсу, інкапсулюється (приховано) у класі. Користувач може працювати з
// усім функціоналом через інтерфейс, не замислюючись про те, як реалізований
// функціонал.

// Абстракція

// Коли ми телефонуємо ми не замислюватиметься про хімічний склад фарби
// панелі, особливості взаємодії внутрішніх деталей тощо. Однак це не
// заважає нам використовувати весь функціонал
// Абстрагування (abstraction) — це спосіб виділити набір значних показників
// об'єкта, крім розгляду незначні.

// Наслідування

// Уявімо що інженерам поставили завдання розробки та випуску
// модельного ряду сучасніших сматфонів. При цьому вони вже мають стару
// модель, яка відмінно зарекомендувала себе. Очевидно, що інженери не
// проектуватимуть новий телефон з нуля, а взявши за основу попереднє
// покоління, внесуть низку конструктивних змін.

// Усі модифікації матимуть більшість властивостей колишньої моделі. При цьому
// кожна з моделей реалізуватиме деяку нову функціональність або конструктивну
// особливість. У даному випадку ми маємо справу з успадкуванням.
// Спадкування (inheritance) - це властивість системи, що дозволяє описати новий
// клас на основі вже існуючого, з частково або повністю функціоналом, що
// запозичується. Клас, від якого виробляється успадкування, називається базовим,
// батьківським чи суперкласом. Новий клас називається нащадком, спадкоємцем
// чи похідним класом.

// Якщо взяти приклад із життя, у нас є HTML-елементи. У наступних модулях ми
// дізнаємося, що всі вони представлені об'єктами. У них є загальні властивості та
// методи для керування станом. Замість того, щоб додавати загальні властивості на
// кожен тип елемента, ми можемо описати їх у класі HTMLElement, і ті елементи,
// яким потрібен подібний інтерфейс, можуть успадковувати HTMLElement.
// Спадкування допомагає зменшити обсяг коду, що повторюється.

// Поліморфізм

// Було б не дуже зручно, якби всі телефони функціонували по різному і власник
// андроїду не міг зателефонувати з айосу чи навпаки.
// Вся справа в тому, що основні елементи використання телефону мають одну й ту
// саму конструкцію та принцип дії. По суті, можна сказати, що всі сматфони мають
// той самий інтерфейс, а користувач, абстрагуючись від сутності смартфону, працює
// саме з цим інтерфейсом. Незалежно від того, яким чином буде реалізовуватись
// дзвінок, інтерфейс залишиться тим самим.

// Поліморфізм (polymorphism) - це властивість системи дозволяє використовувати
// об'єкти з однаковим інтерфейсом без інформації про тип і внутрішню структуру
// об'єкта. Дозволяє перевизначати у класах спадкоємців реалізації методів
// базового класу.
